# -*- coding: utf-8 -*-
"""Anomaly_detector.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p0tUl64SgpmaiIiCNgKRDITYsWj4BKmt
"""

# app.py

import streamlit as st
import pandas as pd


@st.cache_data
def load_reference():
    """
    Load the static reference table defining, for each operation code and pack:
      ‚Äì Amount_pack  : fee when operation is covered by the pack
      ‚Äì Amount       : normal fee outside the pack
    """
    return pd.read_excel("References.xlsx")


def load_uploaded_dataframe(uploaded_file):
    """Helper to read either Excel or CSV into a DataFrame."""
    if uploaded_file.name.lower().endswith(".csv"):
        return pd.read_csv(uploaded_file,dtype={"code_client":str})
    else:
        return pd.read_excel(uploaded_file,dtype={"code_client":str})


def main():
    st.title("Audit Pricing System")
    st.image("logo_saham.png", use_container_width=False)

    # 1) load the reference table (static resource)
    ref_df = load_reference()
    st.sidebar.markdown(f"**Reference loaded:** {len(ref_df)} rows")

    # 2) let the user upload their Operations and Equipment tables
    op_file = st.sidebar.file_uploader("Upload Operations table", type=["xlsx","csv"])
    eq_file = st.sidebar.file_uploader("Upload Equipment table", type=["xlsx","csv"])

    if not op_file or not eq_file:
        st.info("Please upload both Operations and Equipment files (Excel or CSV).")
        return

    # read user tables
    ops_df = load_uploaded_dataframe(op_file)
    eq_df  = load_uploaded_dataframe(eq_file)

    # Show raw uploads
    st.header("üîé Uploaded Data Preview")
    st.subheader("Operations")
    st.dataframe(ops_df.head())
    st.subheader("Equipment")
    st.dataframe(eq_df.head())


    # --- Step 1: filter Operations to only those codes in the reference
    st.header("1Ô∏è‚É£ Filter Operations for Audit")
    ops_restricted = ops_df[ops_df["code_operation"].isin(ref_df["code_operation"])]
    st.write(f"Operations matching reference: **{len(ops_restricted)}** rows")
    st.dataframe(ops_restricted)

    # --- Step 2: build a detailed reference per client
    st.header("2Ô∏è‚É£ Build Detailed Reference per Client")
    ref_client = (
        eq_df
        .merge(ref_df, on="code_pack", how="inner")
        .loc[:, ["code_client","code_pack","date_souscription","code_operation","Amount_pack","Amount"]]
    )
    st.write(f"Reference √ó Client rows: **{len(ref_client)}**")
    st.dataframe(ref_client)

    # --- Step 3: match & detect anomalies
    st.header("3Ô∏è‚É£ Match & Detect Anomalies")
    # merge on (code_client, code_operation, Amount) ‚Üí these are ops charged the *normal* fee
    detected = ops_restricted.merge(
        ref_client,
        on=["code_client","code_operation","Amount"],
        how="inner"
    )
    # cast dates
    detected["date_operation"]    = pd.to_datetime(detected["date_operation"])
    detected["date_souscription"] = pd.to_datetime(detected["date_souscription"])
    # only keep those after the pack subscription date
    detected["code_client"]=detected["code_client"].astype(str)
    anomalies = detected[ detected["date_operation"] > detected["date_souscription"] ]

    if anomalies.empty:
        st.success("‚úÖ No anomaly detected.")
    else:
        st.error(f"‚ö†Ô∏è **Anomalies found: {len(anomalies)} rows**")
        st.dataframe(anomalies)

    st.markdown(
        """
        **How it works**
        1. **Filtered Ops** Garde uniquement les codes op√©ration dans la table de r√©f√©rence.
        2. **Detailed Reference** expansion par package ‚Üí conditions particuli√®re pour chaque client (Jointure par `code_pack`).
        3. **Anomaly Detection** trouve les op√©rations:
           - Les clients qui sont d√©j√† souscrits au pack (`date_operation` > `date_souscription`), et
           - Les clients sont factur√©s par (`Amount`) au lieu du tarif pr√©f√©rentiel.
        """
    )


if __name__ == "__main__":
    main()
